// Package "websocket" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.45.3 DO NOT EDIT.
package websocket

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/lerenn/asyncapi-codegen/pkg/extensions"
)

// AppSubscriber contains all handlers that are listening messages for App
type AppSubscriber interface {
	// ReceiveChildOrderEventsOperationReceived receive all EventsMessageFromChildOrderEventsChannel messages from ChildOrderEvents channel.
	ReceiveChildOrderEventsOperationReceived(ctx context.Context, msg EventsMessageFromChildOrderEventsChannel) error

	// ReceiveExecutionsOperationReceived receive all ExecutionsMessageFromLightningExecutionsChannel messages from LightningExecutions channel.
	ReceiveExecutionsOperationReceived(ctx context.Context, msg ExecutionsMessageFromLightningExecutionsChannel) error

	// ReceiveOrderBookOperationReceived receive all SnapshotMessageFromLightningBoardSnapshotChannel messages from LightningBoardSnapshot channel.
	ReceiveOrderBookOperationReceived(ctx context.Context, msg SnapshotMessageFromLightningBoardSnapshotChannel) error

	// ReceiveOrderBookDiffOperationReceived receive all DiffMessageFromLightningBoardChannel messages from LightningBoard channel.
	ReceiveOrderBookDiffOperationReceived(ctx context.Context, msg DiffMessageFromLightningBoardChannel) error

	// ReceiveParentOrderEventsOperationReceived receive all EventsMessageFromParentOrderEventsChannel messages from ParentOrderEvents channel.
	ReceiveParentOrderEventsOperationReceived(ctx context.Context, msg EventsMessageFromParentOrderEventsChannel) error

	// ReceiveTickerOperationReceived receive all TickerMessageFromLightningTickerChannel messages from LightningTicker channel.
	ReceiveTickerOperationReceived(ctx context.Context, msg TickerMessageFromLightningTickerChannel) error
}

// AppController is the structure that provides sending capabilities to the
// developer and and connect the broker with the App
type AppController struct {
	controller
}

// NewAppController links the App to the broker
func NewAppController(bc extensions.BrokerController, options ...ControllerOption) (*AppController, error) {
	// Check if broker controller has been provided
	if bc == nil {
		return nil, extensions.ErrNilBrokerController
	}

	// Create default controller
	controller := controller{
		broker:        bc,
		subscriptions: make(map[string]extensions.BrokerChannelSubscription),
		logger:        extensions.DummyLogger{},
		middlewares:   make([]extensions.Middleware, 0),
		errorHandler:  extensions.DefaultErrorHandler(),
	}

	// Apply options
	for _, option := range options {
		option(&controller)
	}

	return &AppController{controller: controller}, nil
}

func (c AppController) wrapMiddlewares(
	middlewares []extensions.Middleware,
	callback extensions.NextMiddleware,
) func(ctx context.Context, msg *extensions.BrokerMessage) error {
	var called bool

	// If there is no more middleware
	if len(middlewares) == 0 {
		return func(ctx context.Context, msg *extensions.BrokerMessage) error {
			// Call the callback if it exists and it has not been called already
			if callback != nil && !called {
				called = true
				return callback(ctx)
			}

			// Nil can be returned, as the callback has already been called
			return nil
		}
	}

	// Get the next function to call from next middlewares or callback
	next := c.wrapMiddlewares(middlewares[1:], callback)

	// Wrap middleware into a check function that will call execute the middleware
	// and call the next wrapped middleware if the returned function has not been
	// called already
	return func(ctx context.Context, msg *extensions.BrokerMessage) error {
		// Call the middleware and the following if it has not been done already
		if !called {
			// Create the next call with the context and the message
			nextWithArgs := func(ctx context.Context) error {
				return next(ctx, msg)
			}

			// Call the middleware and register it as already called
			called = true
			if err := middlewares[0](ctx, msg, nextWithArgs); err != nil {
				return err
			}

			// If next has already been called in middleware, it should not be executed again
			return nextWithArgs(ctx)
		}

		// Nil can be returned, as the next middleware has already been called
		return nil
	}
}

func (c AppController) executeMiddlewares(ctx context.Context, msg *extensions.BrokerMessage, callback extensions.NextMiddleware) error {
	// Wrap middleware to have 'next' function when calling them
	wrapped := c.wrapMiddlewares(c.middlewares, callback)

	// Execute wrapped middlewares
	return wrapped(ctx, msg)
}

func addAppContextValues(ctx context.Context, addr string) context.Context {
	ctx = context.WithValue(ctx, extensions.ContextKeyIsVersion, "1.0.0")
	ctx = context.WithValue(ctx, extensions.ContextKeyIsProvider, "app")
	return context.WithValue(ctx, extensions.ContextKeyIsChannel, addr)
}

// Close will clean up any existing resources on the controller
func (c *AppController) Close(ctx context.Context) {
	// Unsubscribing remaining channels
	c.UnsubscribeFromAllChannels(ctx)

	c.logger.Info(ctx, "Closed app controller")
}

// SubscribeToAllChannels will receive messages from channels where channel has
// no parameter on which the app is expecting messages. For channels with parameters,
// they should be subscribed independently.
func (c *AppController) SubscribeToAllChannels(ctx context.Context, as AppSubscriber) error {
	if as == nil {
		return extensions.ErrNilAppSubscriber
	}

	if err := c.SubscribeToReceiveChildOrderEventsOperation(ctx, as.ReceiveChildOrderEventsOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToReceiveExecutionsOperation(ctx, as.ReceiveExecutionsOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToReceiveOrderBookOperation(ctx, as.ReceiveOrderBookOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToReceiveOrderBookDiffOperation(ctx, as.ReceiveOrderBookDiffOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToReceiveParentOrderEventsOperation(ctx, as.ReceiveParentOrderEventsOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToReceiveTickerOperation(ctx, as.ReceiveTickerOperationReceived); err != nil {
		return err
	}

	return nil
}

// UnsubscribeFromAllChannels will stop the subscription of all remaining subscribed channels
func (c *AppController) UnsubscribeFromAllChannels(ctx context.Context) {
	c.UnsubscribeFromReceiveChildOrderEventsOperation(ctx)
	c.UnsubscribeFromReceiveExecutionsOperation(ctx)
	c.UnsubscribeFromReceiveOrderBookOperation(ctx)
	c.UnsubscribeFromReceiveOrderBookDiffOperation(ctx)
	c.UnsubscribeFromReceiveParentOrderEventsOperation(ctx)
	c.UnsubscribeFromReceiveTickerOperation(ctx)
}

// SubscribeToReceiveChildOrderEventsOperation will receive EventsMessageFromChildOrderEventsChannel messages from ChildOrderEvents channel.
//
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveChildOrderEventsOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg EventsMessageFromChildOrderEventsChannel) error,
) error {
	// Get channel address
	addr := "child_order_events"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveChildOrderEventsOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveChildOrderEventsOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg EventsMessageFromChildOrderEventsChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToEventsMessageFromChildOrderEventsChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveChildOrderEventsOperation will stop the reception of EventsMessageFromChildOrderEventsChannel messages from ChildOrderEvents channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveChildOrderEventsOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "child_order_events"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToReceiveExecutionsOperation will receive ExecutionsMessageFromLightningExecutionsChannel messages from LightningExecutions channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveExecutionsOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg ExecutionsMessageFromLightningExecutionsChannel) error,
) error {
	// Get channel address
	addr := "lightning_executions_{product_code}"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveExecutionsOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveExecutionsOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg ExecutionsMessageFromLightningExecutionsChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToExecutionsMessageFromLightningExecutionsChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveExecutionsOperation will stop the reception of ExecutionsMessageFromLightningExecutionsChannel messages from LightningExecutions channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveExecutionsOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "lightning_executions_{product_code}"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToReceiveOrderBookOperation will receive SnapshotMessageFromLightningBoardSnapshotChannel messages from LightningBoardSnapshot channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveOrderBookOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg SnapshotMessageFromLightningBoardSnapshotChannel) error,
) error {
	// Get channel address
	addr := "lightning_board_snapshot_{product_code}"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveOrderBookOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveOrderBookOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg SnapshotMessageFromLightningBoardSnapshotChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToSnapshotMessageFromLightningBoardSnapshotChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveOrderBookOperation will stop the reception of SnapshotMessageFromLightningBoardSnapshotChannel messages from LightningBoardSnapshot channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveOrderBookOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "lightning_board_snapshot_{product_code}"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToReceiveOrderBookDiffOperation will receive DiffMessageFromLightningBoardChannel messages from LightningBoard channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveOrderBookDiffOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg DiffMessageFromLightningBoardChannel) error,
) error {
	// Get channel address
	addr := "lightning_board_{product_code}"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveOrderBookDiffOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveOrderBookDiffOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg DiffMessageFromLightningBoardChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToDiffMessageFromLightningBoardChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveOrderBookDiffOperation will stop the reception of DiffMessageFromLightningBoardChannel messages from LightningBoard channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveOrderBookDiffOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "lightning_board_{product_code}"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToReceiveParentOrderEventsOperation will receive EventsMessageFromParentOrderEventsChannel messages from ParentOrderEvents channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveParentOrderEventsOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg EventsMessageFromParentOrderEventsChannel) error,
) error {
	// Get channel address
	addr := "parent_order_events"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveParentOrderEventsOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveParentOrderEventsOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg EventsMessageFromParentOrderEventsChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToEventsMessageFromParentOrderEventsChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveParentOrderEventsOperation will stop the reception of EventsMessageFromParentOrderEventsChannel messages from ParentOrderEvents channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveParentOrderEventsOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "parent_order_events"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToReceiveTickerOperation will receive TickerMessageFromLightningTickerChannel messages from LightningTicker channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SubscribeToReceiveTickerOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg TickerMessageFromLightningTickerChannel) error,
) error {
	// Get channel address
	addr := "lightning_ticker_{product_code}"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToReceiveTickerOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *AppController) listenToReceiveTickerOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg TickerMessageFromLightningTickerChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addAppContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToTickerMessageFromLightningTickerChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromReceiveTickerOperation will stop the reception of TickerMessageFromLightningTickerChannel messages from LightningTicker channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *AppController) UnsubscribeFromReceiveTickerOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "lightning_ticker_{product_code}"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addAppContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
}

// SendAsSendAuthOperation will send a AuthMessageFromAuthChannel message on Auth channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SendAsSendAuthOperation(
	ctx context.Context,
	msg AuthMessageFromAuthChannel,
) error {
	// Set channel address
	addr := "auth"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendAsSendSubscribeOperation will send a SubscribeMessageFromSubscribeChannel message on Subscribe channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SendAsSendSubscribeOperation(
	ctx context.Context,
	msg SubscribeMessageFromSubscribeChannel,
) error {
	// Set channel address
	addr := "subscribe"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendAsSendUnsubscribeOperation will send a UnsubscribeMessageFromUnsubscribeChannel message on Unsubscribe channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *AppController) SendAsSendUnsubscribeOperation(
	ctx context.Context,
	msg UnsubscribeMessageFromUnsubscribeChannel,
) error {
	// Set channel address
	addr := "unsubscribe"

	// Set context
	ctx = addAppContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// UserSubscriber contains all handlers that are listening messages for User
type UserSubscriber interface {
	// SendAuthOperationReceived receive all AuthMessageFromAuthChannel messages from Auth channel.
	SendAuthOperationReceived(ctx context.Context, msg AuthMessageFromAuthChannel) error

	// SendSubscribeOperationReceived receive all SubscribeMessageFromSubscribeChannel messages from Subscribe channel.
	SendSubscribeOperationReceived(ctx context.Context, msg SubscribeMessageFromSubscribeChannel) error

	// SendUnsubscribeOperationReceived receive all UnsubscribeMessageFromUnsubscribeChannel messages from Unsubscribe channel.
	SendUnsubscribeOperationReceived(ctx context.Context, msg UnsubscribeMessageFromUnsubscribeChannel) error
}

// UserController is the structure that provides sending capabilities to the
// developer and and connect the broker with the User
type UserController struct {
	controller
}

// NewUserController links the User to the broker
func NewUserController(bc extensions.BrokerController, options ...ControllerOption) (*UserController, error) {
	// Check if broker controller has been provided
	if bc == nil {
		return nil, extensions.ErrNilBrokerController
	}

	// Create default controller
	controller := controller{
		broker:        bc,
		subscriptions: make(map[string]extensions.BrokerChannelSubscription),
		logger:        extensions.DummyLogger{},
		middlewares:   make([]extensions.Middleware, 0),
		errorHandler:  extensions.DefaultErrorHandler(),
	}

	// Apply options
	for _, option := range options {
		option(&controller)
	}

	return &UserController{controller: controller}, nil
}

func (c UserController) wrapMiddlewares(
	middlewares []extensions.Middleware,
	callback extensions.NextMiddleware,
) func(ctx context.Context, msg *extensions.BrokerMessage) error {
	var called bool

	// If there is no more middleware
	if len(middlewares) == 0 {
		return func(ctx context.Context, msg *extensions.BrokerMessage) error {
			// Call the callback if it exists and it has not been called already
			if callback != nil && !called {
				called = true
				return callback(ctx)
			}

			// Nil can be returned, as the callback has already been called
			return nil
		}
	}

	// Get the next function to call from next middlewares or callback
	next := c.wrapMiddlewares(middlewares[1:], callback)

	// Wrap middleware into a check function that will call execute the middleware
	// and call the next wrapped middleware if the returned function has not been
	// called already
	return func(ctx context.Context, msg *extensions.BrokerMessage) error {
		// Call the middleware and the following if it has not been done already
		if !called {
			// Create the next call with the context and the message
			nextWithArgs := func(ctx context.Context) error {
				return next(ctx, msg)
			}

			// Call the middleware and register it as already called
			called = true
			if err := middlewares[0](ctx, msg, nextWithArgs); err != nil {
				return err
			}

			// If next has already been called in middleware, it should not be executed again
			return nextWithArgs(ctx)
		}

		// Nil can be returned, as the next middleware has already been called
		return nil
	}
}

func (c UserController) executeMiddlewares(ctx context.Context, msg *extensions.BrokerMessage, callback extensions.NextMiddleware) error {
	// Wrap middleware to have 'next' function when calling them
	wrapped := c.wrapMiddlewares(c.middlewares, callback)

	// Execute wrapped middlewares
	return wrapped(ctx, msg)
}

func addUserContextValues(ctx context.Context, addr string) context.Context {
	ctx = context.WithValue(ctx, extensions.ContextKeyIsVersion, "1.0.0")
	ctx = context.WithValue(ctx, extensions.ContextKeyIsProvider, "user")
	return context.WithValue(ctx, extensions.ContextKeyIsChannel, addr)
}

// Close will clean up any existing resources on the controller
func (c *UserController) Close(ctx context.Context) {
	// Unsubscribing remaining channels
	c.UnsubscribeFromAllChannels(ctx)

	c.logger.Info(ctx, "Closed user controller")
}

// SubscribeToAllChannels will receive messages from channels where channel has
// no parameter on which the app is expecting messages. For channels with parameters,
// they should be subscribed independently.
func (c *UserController) SubscribeToAllChannels(ctx context.Context, as UserSubscriber) error {
	if as == nil {
		return extensions.ErrNilUserSubscriber
	}

	if err := c.SubscribeToSendAuthOperation(ctx, as.SendAuthOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToSendSubscribeOperation(ctx, as.SendSubscribeOperationReceived); err != nil {
		return err
	}
	if err := c.SubscribeToSendUnsubscribeOperation(ctx, as.SendUnsubscribeOperationReceived); err != nil {
		return err
	}

	return nil
}

// UnsubscribeFromAllChannels will stop the subscription of all remaining subscribed channels
func (c *UserController) UnsubscribeFromAllChannels(ctx context.Context) {
	c.UnsubscribeFromSendAuthOperation(ctx)
	c.UnsubscribeFromSendSubscribeOperation(ctx)
	c.UnsubscribeFromSendUnsubscribeOperation(ctx)
}

// SubscribeToSendAuthOperation will receive AuthMessageFromAuthChannel messages from Auth channel.
//
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SubscribeToSendAuthOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg AuthMessageFromAuthChannel) error,
) error {
	// Get channel address
	addr := "auth"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToSendAuthOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *UserController) listenToSendAuthOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg AuthMessageFromAuthChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addUserContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToAuthMessageFromAuthChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromSendAuthOperation will stop the reception of AuthMessageFromAuthChannel messages from Auth channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *UserController) UnsubscribeFromSendAuthOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "auth"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addUserContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToSendSubscribeOperation will receive SubscribeMessageFromSubscribeChannel messages from Subscribe channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SubscribeToSendSubscribeOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg SubscribeMessageFromSubscribeChannel) error,
) error {
	// Get channel address
	addr := "subscribe"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToSendSubscribeOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *UserController) listenToSendSubscribeOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg SubscribeMessageFromSubscribeChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addUserContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToSubscribeMessageFromSubscribeChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromSendSubscribeOperation will stop the reception of SubscribeMessageFromSubscribeChannel messages from Subscribe channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *UserController) UnsubscribeFromSendSubscribeOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "subscribe"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addUserContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
} // SubscribeToSendUnsubscribeOperation will receive UnsubscribeMessageFromUnsubscribeChannel messages from Unsubscribe channel.
// Callback function 'fn' will be called each time a new message is received.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SubscribeToSendUnsubscribeOperation(
	ctx context.Context,
	fn func(ctx context.Context, msg UnsubscribeMessageFromUnsubscribeChannel) error,
) error {
	// Get channel address
	addr := "unsubscribe"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "reception")

	// Check if the controller is already subscribed
	_, exists := c.subscriptions[addr]
	if exists {
		err := fmt.Errorf("%w: controller is already subscribed on channel %q", extensions.ErrAlreadySubscribedChannel, addr)
		c.logger.Error(ctx, err.Error())
		return err
	}

	// Subscribe to broker channel
	sub, err := c.broker.Subscribe(ctx, addr)
	if err != nil {
		c.logger.Error(ctx, err.Error())
		return err
	}
	c.logger.Info(ctx, "Subscribed to channel")

	// Asynchronously listen to new messages and pass them to app receiver
	go func() {
		for {
			// Listen to next message
			stop, err := c.listenToSendUnsubscribeOperationNextMessage(addr, sub, fn)
			if err != nil {
				c.logger.Error(ctx, err.Error())
			}

			// Stop if required
			if stop {
				return
			}
		}
	}()

	// Add the cancel channel to the inside map
	c.subscriptions[addr] = sub

	return nil
}

func (c *UserController) listenToSendUnsubscribeOperationNextMessage(
	addr string,
	sub extensions.BrokerChannelSubscription,
	fn func(ctx context.Context, msg UnsubscribeMessageFromUnsubscribeChannel) error,
) (stop bool, err error) {
	// Create a context for the received response
	msgCtx, cancel := context.WithCancel(context.Background())
	msgCtx = addUserContextValues(msgCtx, addr)
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsDirection, "reception")
	defer cancel()

	// Wait for next message
	acknowledgeableBrokerMessage, open := <-sub.MessagesChannel()

	// If subscription is closed and there is no more message
	// (i.e. uninitialized message), then exit the function
	if !open && acknowledgeableBrokerMessage.IsUninitialized() {
		return true, nil
	}

	// Set broker message to context
	msgCtx = context.WithValue(msgCtx, extensions.ContextKeyIsBrokerMessage, acknowledgeableBrokerMessage.String())

	// Execute middlewares before handling the message
	if err := c.executeMiddlewares(msgCtx, &acknowledgeableBrokerMessage.BrokerMessage, func(middlewareCtx context.Context) error {
		// Process message
		msg, err := brokerMessageToUnsubscribeMessageFromUnsubscribeChannel(acknowledgeableBrokerMessage.BrokerMessage)
		if err != nil {
			return err
		}

		// Execute the subscription function
		if err := fn(middlewareCtx, msg); err != nil {
			return err
		}

		acknowledgeableBrokerMessage.Ack()

		return nil
	}); err != nil {
		c.errorHandler(msgCtx, addr, &acknowledgeableBrokerMessage, err)
		// On error execute the acknowledgeableBrokerMessage nack() function and
		// let the BrokerAcknowledgment decide what is the right nack behavior for the broker
		acknowledgeableBrokerMessage.Nak()
	}

	return false, nil
}

// UnsubscribeFromSendUnsubscribeOperation will stop the reception of UnsubscribeMessageFromUnsubscribeChannel messages from Unsubscribe channel.
// A timeout can be set in context to avoid blocking operation, if needed.
func (c *UserController) UnsubscribeFromSendUnsubscribeOperation(
	ctx context.Context,
) {
	// Get channel address
	addr := "unsubscribe"

	// Check if there receivers for this channel
	sub, exists := c.subscriptions[addr]
	if !exists {
		return
	}

	// Set context
	ctx = addUserContextValues(ctx, addr)

	// Stop the subscription
	sub.Cancel(ctx)

	// Remove if from the receivers
	delete(c.subscriptions, addr)

	c.logger.Info(ctx, "Unsubscribed from channel")
}

// SendToReceiveChildOrderEventsOperation will send a EventsMessageFromChildOrderEventsChannel message on ChildOrderEvents channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveChildOrderEventsOperation(
	ctx context.Context,
	msg EventsMessageFromChildOrderEventsChannel,
) error {
	// Set channel address
	addr := "child_order_events"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendToReceiveExecutionsOperation will send a ExecutionsMessageFromLightningExecutionsChannel message on LightningExecutions channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveExecutionsOperation(
	ctx context.Context,
	msg ExecutionsMessageFromLightningExecutionsChannel,
) error {
	// Set channel address
	addr := "lightning_executions_{product_code}"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendToReceiveOrderBookOperation will send a SnapshotMessageFromLightningBoardSnapshotChannel message on LightningBoardSnapshot channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveOrderBookOperation(
	ctx context.Context,
	msg SnapshotMessageFromLightningBoardSnapshotChannel,
) error {
	// Set channel address
	addr := "lightning_board_snapshot_{product_code}"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendToReceiveOrderBookDiffOperation will send a DiffMessageFromLightningBoardChannel message on LightningBoard channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveOrderBookDiffOperation(
	ctx context.Context,
	msg DiffMessageFromLightningBoardChannel,
) error {
	// Set channel address
	addr := "lightning_board_{product_code}"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendToReceiveParentOrderEventsOperation will send a EventsMessageFromParentOrderEventsChannel message on ParentOrderEvents channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveParentOrderEventsOperation(
	ctx context.Context,
	msg EventsMessageFromParentOrderEventsChannel,
) error {
	// Set channel address
	addr := "parent_order_events"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// SendToReceiveTickerOperation will send a TickerMessageFromLightningTickerChannel message on LightningTicker channel.
//
// NOTE: for now, this only support the first message from AsyncAPI list.
// If you need support for other messages, please raise an issue.
func (c *UserController) SendToReceiveTickerOperation(
	ctx context.Context,
	msg TickerMessageFromLightningTickerChannel,
) error {
	// Set channel address
	addr := "lightning_ticker_{product_code}"

	// Set context
	ctx = addUserContextValues(ctx, addr)
	ctx = context.WithValue(ctx, extensions.ContextKeyIsDirection, "publication")

	// Convert to BrokerMessage
	brokerMsg, err := msg.toBrokerMessage()
	if err != nil {
		return err
	}

	// Set broker message to context
	ctx = context.WithValue(ctx, extensions.ContextKeyIsBrokerMessage, brokerMsg.String())

	// Send the message on event-broker through middlewares
	return c.executeMiddlewares(ctx, &brokerMsg, func(ctx context.Context) error {
		return c.broker.Publish(ctx, addr, brokerMsg)
	})
}

// AsyncAPIVersion is the version of the used AsyncAPI document
const AsyncAPIVersion = "1.0.0"

// controller is the controller that will be used to communicate with the broker
// It will be used internally by AppController and UserController
type controller struct {
	// broker is the broker controller that will be used to communicate
	broker extensions.BrokerController
	// subscriptions is a map of all subscriptions
	subscriptions map[string]extensions.BrokerChannelSubscription
	// logger is the logger that will be used² to log operations on controller
	logger extensions.Logger
	// middlewares are the middlewares that will be executed when sending or
	// receiving messages
	middlewares []extensions.Middleware
	// handler to handle errors from consumers and middlewares
	errorHandler extensions.ErrorHandler
}

// ControllerOption is the type of the options that can be passed
// when creating a new Controller
type ControllerOption func(controller *controller)

// WithLogger attaches a logger to the controller
func WithLogger(logger extensions.Logger) ControllerOption {
	return func(controller *controller) {
		controller.logger = logger
	}
}

// WithMiddlewares attaches middlewares that will be executed when sending or receiving messages
func WithMiddlewares(middlewares ...extensions.Middleware) ControllerOption {
	return func(controller *controller) {
		controller.middlewares = middlewares
	}
}

// WithErrorHandler attaches a errorhandler to handle errors from subscriber functions
func WithErrorHandler(handler extensions.ErrorHandler) ControllerOption {
	return func(controller *controller) {
		controller.errorHandler = handler
	}
}

type MessageWithCorrelationID interface {
	CorrelationID() string
	SetCorrelationID(id string)
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// AuthMessageFromAuthChannelPayload is a schema from the AsyncAPI specification required in messages
type AuthMessageFromAuthChannelPayload struct {
	// Description: API Key
	ApiKey string `json:"api_key"`

	// Description: Random string (16-255 characters)
	Nonce string `json:"nonce"`

	// Description: Hex string signed with HMAC SHA256 using API Secret
	Signature string `json:"signature"`

	// Description: Current Unix Timestamp (10 or 13 digits)
	Timestamp int64 `json:"timestamp"`
}

// AuthMessageFromAuthChannel is the message expected for 'AuthMessageFromAuthChannel' channel.
type AuthMessageFromAuthChannel struct {
	// Payload will be inserted in the message payload
	Payload AuthMessageFromAuthChannelPayload
}

func NewAuthMessageFromAuthChannel() AuthMessageFromAuthChannel {
	var msg AuthMessageFromAuthChannel

	return msg
}

// brokerMessageToAuthMessageFromAuthChannel will fill a new AuthMessageFromAuthChannel with data from generic broker message
func brokerMessageToAuthMessageFromAuthChannel(bMsg extensions.BrokerMessage) (AuthMessageFromAuthChannel, error) {
	var msg AuthMessageFromAuthChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AuthMessageFromAuthChannel data
func (msg AuthMessageFromAuthChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// EventsMessageFromChildOrderEventsChannelPayload is a schema from the AsyncAPI specification required in messages
type EventsMessageFromChildOrderEventsChannelPayload []ChildOrderEventSchema

// EventsMessageFromChildOrderEventsChannel is the message expected for 'EventsMessageFromChildOrderEventsChannel' channel.
type EventsMessageFromChildOrderEventsChannel struct {
	// Payload will be inserted in the message payload
	Payload []ChildOrderEventSchema
}

func NewEventsMessageFromChildOrderEventsChannel() EventsMessageFromChildOrderEventsChannel {
	var msg EventsMessageFromChildOrderEventsChannel

	return msg
}

// brokerMessageToEventsMessageFromChildOrderEventsChannel will fill a new EventsMessageFromChildOrderEventsChannel with data from generic broker message
func brokerMessageToEventsMessageFromChildOrderEventsChannel(bMsg extensions.BrokerMessage) (EventsMessageFromChildOrderEventsChannel, error) {
	var msg EventsMessageFromChildOrderEventsChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from EventsMessageFromChildOrderEventsChannel data
func (msg EventsMessageFromChildOrderEventsChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// DiffMessageFromLightningBoardChannelPayload is a schema from the AsyncAPI specification required in messages
type DiffMessageFromLightningBoardChannelPayload struct {
	// Description: Order information (Snapshot/Diff of Order Book)
	Data OrderBookSchema `json:"data"`

	// Description: Market product code (example: `BTC_JPY`, `FX_BTC_JPY`, `ETH_BTC`)
	ProductCode string `json:"product_code"`
}

// DiffMessageFromLightningBoardChannel is the message expected for 'DiffMessageFromLightningBoardChannel' channel.
type DiffMessageFromLightningBoardChannel struct {
	// Payload will be inserted in the message payload
	Payload DiffMessageFromLightningBoardChannelPayload
}

func NewDiffMessageFromLightningBoardChannel() DiffMessageFromLightningBoardChannel {
	var msg DiffMessageFromLightningBoardChannel

	return msg
}

// brokerMessageToDiffMessageFromLightningBoardChannel will fill a new DiffMessageFromLightningBoardChannel with data from generic broker message
func brokerMessageToDiffMessageFromLightningBoardChannel(bMsg extensions.BrokerMessage) (DiffMessageFromLightningBoardChannel, error) {
	var msg DiffMessageFromLightningBoardChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from DiffMessageFromLightningBoardChannel data
func (msg DiffMessageFromLightningBoardChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// SnapshotMessageFromLightningBoardSnapshotChannelPayload is a schema from the AsyncAPI specification required in messages
type SnapshotMessageFromLightningBoardSnapshotChannelPayload struct {
	// Description: Order information (Snapshot/Diff of Order Book)
	Data OrderBookSchema `json:"data"`

	// Description: Market product code (example: `BTC_JPY`, `FX_BTC_JPY`, `ETH_BTC`)
	ProductCode string `json:"product_code"`
}

// SnapshotMessageFromLightningBoardSnapshotChannel is the message expected for 'SnapshotMessageFromLightningBoardSnapshotChannel' channel.
type SnapshotMessageFromLightningBoardSnapshotChannel struct {
	// Payload will be inserted in the message payload
	Payload SnapshotMessageFromLightningBoardSnapshotChannelPayload
}

func NewSnapshotMessageFromLightningBoardSnapshotChannel() SnapshotMessageFromLightningBoardSnapshotChannel {
	var msg SnapshotMessageFromLightningBoardSnapshotChannel

	return msg
}

// brokerMessageToSnapshotMessageFromLightningBoardSnapshotChannel will fill a new SnapshotMessageFromLightningBoardSnapshotChannel with data from generic broker message
func brokerMessageToSnapshotMessageFromLightningBoardSnapshotChannel(bMsg extensions.BrokerMessage) (SnapshotMessageFromLightningBoardSnapshotChannel, error) {
	var msg SnapshotMessageFromLightningBoardSnapshotChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SnapshotMessageFromLightningBoardSnapshotChannel data
func (msg SnapshotMessageFromLightningBoardSnapshotChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// ExecutionsMessageFromLightningExecutionsChannelPayload is a schema from the AsyncAPI specification required in messages
type ExecutionsMessageFromLightningExecutionsChannelPayload struct {
	Data []ExecutionSchema `json:"data" validate:"required"`

	// Description: Market product code (example: `BTC_JPY`, `FX_BTC_JPY`, `ETH_BTC`)
	ProductCode string `json:"product_code"`
}

// ExecutionsMessageFromLightningExecutionsChannel is the message expected for 'ExecutionsMessageFromLightningExecutionsChannel' channel.
type ExecutionsMessageFromLightningExecutionsChannel struct {
	// Payload will be inserted in the message payload
	Payload ExecutionsMessageFromLightningExecutionsChannelPayload
}

func NewExecutionsMessageFromLightningExecutionsChannel() ExecutionsMessageFromLightningExecutionsChannel {
	var msg ExecutionsMessageFromLightningExecutionsChannel

	return msg
}

// brokerMessageToExecutionsMessageFromLightningExecutionsChannel will fill a new ExecutionsMessageFromLightningExecutionsChannel with data from generic broker message
func brokerMessageToExecutionsMessageFromLightningExecutionsChannel(bMsg extensions.BrokerMessage) (ExecutionsMessageFromLightningExecutionsChannel, error) {
	var msg ExecutionsMessageFromLightningExecutionsChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ExecutionsMessageFromLightningExecutionsChannel data
func (msg ExecutionsMessageFromLightningExecutionsChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// TickerMessageFromLightningTickerChannelPayload is a schema from the AsyncAPI specification required in messages
type TickerMessageFromLightningTickerChannelPayload struct {
	// Description: Ticker Information
	Data TickerSchema `json:"data"`

	// Description: Market product code (example: `BTC_JPY`, `FX_BTC_JPY`, `ETH_BTC`)
	ProductCode string `json:"product_code"`
}

// TickerMessageFromLightningTickerChannel is the message expected for 'TickerMessageFromLightningTickerChannel' channel.
type TickerMessageFromLightningTickerChannel struct {
	// Payload will be inserted in the message payload
	Payload TickerMessageFromLightningTickerChannelPayload
}

func NewTickerMessageFromLightningTickerChannel() TickerMessageFromLightningTickerChannel {
	var msg TickerMessageFromLightningTickerChannel

	return msg
}

// brokerMessageToTickerMessageFromLightningTickerChannel will fill a new TickerMessageFromLightningTickerChannel with data from generic broker message
func brokerMessageToTickerMessageFromLightningTickerChannel(bMsg extensions.BrokerMessage) (TickerMessageFromLightningTickerChannel, error) {
	var msg TickerMessageFromLightningTickerChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from TickerMessageFromLightningTickerChannel data
func (msg TickerMessageFromLightningTickerChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// EventsMessageFromParentOrderEventsChannelPayload is a schema from the AsyncAPI specification required in messages
type EventsMessageFromParentOrderEventsChannelPayload []ParentOrderEventSchema

// EventsMessageFromParentOrderEventsChannel is the message expected for 'EventsMessageFromParentOrderEventsChannel' channel.
type EventsMessageFromParentOrderEventsChannel struct {
	// Payload will be inserted in the message payload
	Payload []ParentOrderEventSchema
}

func NewEventsMessageFromParentOrderEventsChannel() EventsMessageFromParentOrderEventsChannel {
	var msg EventsMessageFromParentOrderEventsChannel

	return msg
}

// brokerMessageToEventsMessageFromParentOrderEventsChannel will fill a new EventsMessageFromParentOrderEventsChannel with data from generic broker message
func brokerMessageToEventsMessageFromParentOrderEventsChannel(bMsg extensions.BrokerMessage) (EventsMessageFromParentOrderEventsChannel, error) {
	var msg EventsMessageFromParentOrderEventsChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from EventsMessageFromParentOrderEventsChannel data
func (msg EventsMessageFromParentOrderEventsChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// SubscribeMessageFromSubscribeChannelPayload is a schema from the AsyncAPI specification required in messages
type SubscribeMessageFromSubscribeChannelPayload struct {
	// Description: Channel name to subscribe to
	Channel string `json:"channel"`
}

// SubscribeMessageFromSubscribeChannel is the message expected for 'SubscribeMessageFromSubscribeChannel' channel.
type SubscribeMessageFromSubscribeChannel struct {
	// Payload will be inserted in the message payload
	Payload SubscribeMessageFromSubscribeChannelPayload
}

func NewSubscribeMessageFromSubscribeChannel() SubscribeMessageFromSubscribeChannel {
	var msg SubscribeMessageFromSubscribeChannel

	return msg
}

// brokerMessageToSubscribeMessageFromSubscribeChannel will fill a new SubscribeMessageFromSubscribeChannel with data from generic broker message
func brokerMessageToSubscribeMessageFromSubscribeChannel(bMsg extensions.BrokerMessage) (SubscribeMessageFromSubscribeChannel, error) {
	var msg SubscribeMessageFromSubscribeChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SubscribeMessageFromSubscribeChannel data
func (msg SubscribeMessageFromSubscribeChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// UnsubscribeMessageFromUnsubscribeChannelPayload is a schema from the AsyncAPI specification required in messages
type UnsubscribeMessageFromUnsubscribeChannelPayload struct {
	// Description: Channel name to unsubscribe from
	Channel string `json:"channel"`
}

// UnsubscribeMessageFromUnsubscribeChannel is the message expected for 'UnsubscribeMessageFromUnsubscribeChannel' channel.
type UnsubscribeMessageFromUnsubscribeChannel struct {
	// Payload will be inserted in the message payload
	Payload UnsubscribeMessageFromUnsubscribeChannelPayload
}

func NewUnsubscribeMessageFromUnsubscribeChannel() UnsubscribeMessageFromUnsubscribeChannel {
	var msg UnsubscribeMessageFromUnsubscribeChannel

	return msg
}

// brokerMessageToUnsubscribeMessageFromUnsubscribeChannel will fill a new UnsubscribeMessageFromUnsubscribeChannel with data from generic broker message
func brokerMessageToUnsubscribeMessageFromUnsubscribeChannel(bMsg extensions.BrokerMessage) (UnsubscribeMessageFromUnsubscribeChannel, error) {
	var msg UnsubscribeMessageFromUnsubscribeChannel

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from UnsubscribeMessageFromUnsubscribeChannel data
func (msg UnsubscribeMessageFromUnsubscribeChannel) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// ChildOrderEventSchema is a schema from the AsyncAPI specification required in messages
// Description: Child Order Event Information
type ChildOrderEventSchema struct {
	// Description: Child Order Acceptance ID
	ChildOrderAcceptanceId string `json:"child_order_acceptance_id"`

	// Description: Child Order ID
	ChildOrderId string `json:"child_order_id"`

	// Description: Child Order Type (Example: LIMIT, MARKET)
	ChildOrderType *string `json:"child_order_type,omitempty"`

	// Description: Commission
	Commission *float64 `json:"commission,omitempty"`

	// Description: Event Occurrence Time
	EventDate time.Time `json:"event_date"`

	// Description: Event Type (`ORDER`, `ORDER_FAILED`, `CANCEL`, `CANCEL_FAILED`, `EXECUTION`, `EXPIRE`)
	EventType string `json:"event_type"`

	// Description: Execution ID (EXECUTION Event)
	ExecId *int64 `json:"exec_id,omitempty"`

	// Description: Order Validity Period
	ExpireDate *time.Time `json:"expire_date,omitempty"`

	// Description: Unexecuted Quantity
	OutstandingSize *float64 `json:"outstanding_size,omitempty"`

	// Description: Price
	Price *float64 `json:"price,omitempty"`

	// Description: Product Code
	ProductCode string `json:"product_code"`

	// Description: Reason for Order Failure
	Reason *string `json:"reason,omitempty"`

	// Description: SFD Deduction Amount
	Sfd *float64 `json:"sfd,omitempty"`

	// Description: Buy/Sell Type (BUY/SELL)
	Side *string `json:"side,omitempty"`

	// Description: Quantity
	Size *float64 `json:"size,omitempty"`
}

// ExecutionSchema is a schema from the AsyncAPI specification required in messages
// Description: Execution Details
type ExecutionSchema struct {
	// Description: Buy Order Acceptance ID
	BuyChildOrderAcceptanceId string `json:"buy_child_order_acceptance_id"`

	// Description: Execution Time
	ExecDate time.Time `json:"exec_date"`

	// Description: Execution ID
	Id int64 `json:"id"`

	// Description: Execution Price
	Price float64 `json:"price"`

	// Description: Sell Order Acceptance ID
	SellChildOrderAcceptanceId string `json:"sell_child_order_acceptance_id"`

	// Description: Buy/Sell Direction (`BUY`/`SELL`, Empty String for Matching)
	Side string `json:"side"`

	// Description: Execution Quantity
	Size float64 `json:"size"`
}

// OrderBookSchema is a schema from the AsyncAPI specification required in messages
// Description: Order information (Snapshot/Diff of Order Book)
type OrderBookSchema struct {
	// Description: Sell order list
	Asks []QuoteEntrySchema `json:"asks" validate:"required"`

	// Description: Buy order list
	Bids []QuoteEntrySchema `json:"bids" validate:"required"`

	// Description: Mid Price (Average of Best Bid and Best Ask)
	MidPrice float64 `json:"mid_price"`
}

// ParentOrderEventSchema is a schema from the AsyncAPI specification required in messages
// Description: Parent Order Event Information
type ParentOrderEventSchema struct {
	// Description: Child Order Acceptance ID
	ChildOrderAcceptanceId *string `json:"child_order_acceptance_id,omitempty"`

	// Description: Child Order Type (Example: LIMIT, MARKET)
	ChildOrderType *string `json:"child_order_type,omitempty"`

	// Description: Event Occurrence Time
	EventDate time.Time `json:"event_date"`

	// Description: Event Type (`ORDER`, `ORDER_FAILED`, `CANCEL`, `TRIGGER`, `COMPLETE`, `EXPIRE`)
	EventType string `json:"event_type"`

	// Description: Order Validity Period
	ExpireDate *time.Time `json:"expire_date,omitempty"`

	// Description: Child Order Number
	ParameterIndex *int64 `json:"parameter_index,omitempty"`

	// Description: Parent Order Acceptance ID
	ParentOrderAcceptanceId string `json:"parent_order_acceptance_id"`

	// Description: Parent Order ID
	ParentOrderId string `json:"parent_order_id"`

	// Description: Parent Order Type (Example: IFD, OCO, IFDOCO, STOP)
	ParentOrderType *string `json:"parent_order_type,omitempty"`

	// Description: Price
	Price *float64 `json:"price,omitempty"`

	// Description: Product Code
	ProductCode string `json:"product_code"`

	// Description: Reason for Parent Order Failure
	Reason *string `json:"reason,omitempty"`

	// Description: Buy/Sell Type (BUY/SELL)
	Side *string `json:"side,omitempty"`

	// Description: Quantity
	Size *float64 `json:"size,omitempty"`
}

// QuoteEntrySchema is a schema from the AsyncAPI specification required in messages
// Description: Order information on the board (Price and Quantity)
type QuoteEntrySchema struct {
	// Description: Price
	Price float64 `json:"price"`

	// Description: Quantity
	Size float64 `json:"size"`
}

// TickerSchema is a schema from the AsyncAPI specification required in messages
// Description: Ticker Information
type TickerSchema struct {
	// Description: Best Ask (Best Sell Quote)
	BestAsk float64 `json:"best_ask"`

	// Description: Best Ask Quantity
	BestAskSize float64 `json:"best_ask_size"`

	// Description: Best Bid (Best Buy Quote)
	BestBid float64 `json:"best_bid"`

	// Description: Best Bid Quantity
	BestBidSize float64 `json:"best_bid_size"`

	// Description: Last Trade Price (Last Trade Price)
	Ltp float64 `json:"ltp"`

	// Description: Market Sell Quantity in Matching
	MarketAskSize float64 `json:"market_ask_size"`

	// Description: Market Buy Quantity in Matching
	MarketBidSize float64 `json:"market_bid_size"`

	// Description: Product Code
	ProductCode string `json:"product_code"`

	// Description: Market State
	State string `json:"state"`

	// Description: Tick ID
	TickId int64 `json:"tick_id"`

	// Description: Time (ISO 8601)
	Timestamp time.Time `json:"timestamp"`

	// Description: Total Sell Quantity
	TotalAskDepth float64 `json:"total_ask_depth"`

	// Description: Total Buy Quantity
	TotalBidDepth float64 `json:"total_bid_depth"`

	// Description: Transaction Volume in the Last 24 Hours
	Volume float64 `json:"volume"`

	// Description: Transaction Volume in the Last 24 Hours (Product-by-Product)
	VolumeByProduct float64 `json:"volume_by_product"`
}

const (
	// AuthChannelPath is the constant representing the 'AuthChannel' channel path.
	AuthChannelPath = "auth"
	// ChildOrderEventsChannelPath is the constant representing the 'ChildOrderEventsChannel' channel path.
	ChildOrderEventsChannelPath = "child_order_events"
	// LightningBoardChannelPath is the constant representing the 'LightningBoardChannel' channel path.
	LightningBoardChannelPath = "lightning_board_{product_code}"
	// LightningBoardSnapshotChannelPath is the constant representing the 'LightningBoardSnapshotChannel' channel path.
	LightningBoardSnapshotChannelPath = "lightning_board_snapshot_{product_code}"
	// LightningExecutionsChannelPath is the constant representing the 'LightningExecutionsChannel' channel path.
	LightningExecutionsChannelPath = "lightning_executions_{product_code}"
	// LightningTickerChannelPath is the constant representing the 'LightningTickerChannel' channel path.
	LightningTickerChannelPath = "lightning_ticker_{product_code}"
	// ParentOrderEventsChannelPath is the constant representing the 'ParentOrderEventsChannel' channel path.
	ParentOrderEventsChannelPath = "parent_order_events"
	// SubscribeChannelPath is the constant representing the 'SubscribeChannel' channel path.
	SubscribeChannelPath = "subscribe"
	// UnsubscribeChannelPath is the constant representing the 'UnsubscribeChannel' channel path.
	UnsubscribeChannelPath = "unsubscribe"
)

// ChannelsPaths is an array of all channels paths
var ChannelsPaths = []string{
	AuthChannelPath,
	ChildOrderEventsChannelPath,
	LightningBoardChannelPath,
	LightningBoardSnapshotChannelPath,
	LightningExecutionsChannelPath,
	LightningTickerChannelPath,
	ParentOrderEventsChannelPath,
	SubscribeChannelPath,
	UnsubscribeChannelPath,
}
